"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[787],{75636:function(e){e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Instantiates and returns a new SortedArray, with optional parameters.","params":[{"name":"BaseArray","desc":"An array of data which will be sorted upon instantiation. If this is omitted, an empty array is used.","lua_type":"Array<T>?"},{"name":"Comparison","desc":"An optional comparison function which is used to customize the element sorting, which will be given two elements `A` and `B` from the array as parameters. The function should return a boolean value specifying whether the first argument should be before the second argument in the sequence. If no comparison function is passed, the Lua-default `A < B` sorting is used.","lua_type":"<T>((A: T, B: T) -> boolean)?"}],"returns":[{"desc":"","lua_type":"SortedArray<T>"}],"function_type":"static","source":{"line":48,"path":"src/DataStructures/SortedArray/init.lua"}},{"name":"ForEach","desc":"Runs the given function on every element in the array.\\n\\n```lua\\nSortedArray.new({1, 2, 3}):ForEach(function(Value)\\n\\tprint(Value)\\nend) -- prints 1, 2, and 3\\n```","params":[{"name":"Function","desc":"The function you are running.","lua_type":"<T>(Value: T, Index: int, self: SortedArray<T>) -> ()"}],"returns":[],"function_type":"method","source":{"line":112,"path":"src/DataStructures/SortedArray/init.lua"}},{"name":"Map","desc":"Maps the SortedArray to a new array using the given predicate.\\n\\n```lua\\nprint(SortedArray.new({1, 2, 3}):Map(function(Value)\\n\\treturn Value * 2\\nend)) -- {2, 4, 6}\\n```","params":[{"name":"Predicate","desc":"The function you are running.","lua_type":"<T>(Value: T, Index: int, self: SortedArray<T>) -> T?"}],"returns":[{"desc":"The mapped array.","lua_type":"Array<T>"}],"function_type":"method","source":{"line":130,"path":"src/DataStructures/SortedArray/init.lua"}},{"name":"MapToSortedArray","desc":"Maps the SortedArray to a new SortedArray using the given predicate.\\n\\n```lua\\nprint(SortedArray.new({1, 2, 3}):MapToSortedArray(function(Value)\\n\\treturn Value * 2\\nend)) -- SortedArray<[2, 4, 6]>\\n```","params":[{"name":"Predicate","desc":"The function you are running.","lua_type":"<T>(Value: T, Index: int, self: SortedArray<T>) -> T?"}],"returns":[{"desc":"The mapped array.","lua_type":"SortedArray<T>"}],"function_type":"method","source":{"line":151,"path":"src/DataStructures/SortedArray/init.lua"}},{"name":"Some","desc":"Runs every the given predicate on every element in the array to check if some value in the array satisfies the predicate.\\n\\n```lua\\nprint(SortedArray.new({2, 4, 6, 8}):Some(function(Value)\\n\\treturn Value == 4\\nend)) -- true\\n\\nprint(SortedArray.new({1, 2, 4, 6, 8}):Some(function(Value)\\n\\treturn Value == 3\\nend)) -- false\\n```","params":[{"name":"Predicate","desc":"The function you are running.","lua_type":"<T>(Value: T, Index: int, self: SortedArray<T>) -> boolean?"}],"returns":[{"desc":"Whether or not the predicate was satisfied.","lua_type":"boolean"}],"function_type":"method","source":{"line":179,"path":"src/DataStructures/SortedArray/init.lua"}},{"name":"Every","desc":"Runs every the given predicate on every element in the array to check if every value in the array satisfies the predicate.\\n\\n```lua\\nprint(SortedArray.new({2, 4, 6, 8}):Every(function(Value)\\n\\treturn Value % 2 == 0\\nend)) -- true\\n\\nprint(SortedArray.new({1, 2, 4, 6, 8}):Every(function(Value)\\n\\treturn Value % 2 == 0\\nend)) -- false\\n```","params":[{"name":"Predicate","desc":"The function you are running.","lua_type":"<T>(Value: T, Index: int, self: SortedArray<T>) -> boolean?"}],"returns":[{"desc":"Whether or not the predicate was satisfied.","lua_type":"boolean"}],"function_type":"method","source":{"line":205,"path":"src/DataStructures/SortedArray/init.lua"}},{"name":"Reduce","desc":"The Reduce method executes a user-supplied \\"reducer\\" callback function on each element of the array, in order, passing in the return value\\nfrom the calculation on the preceding element. The final result of running the reducer across all elements of the array is a single value.\\n\\n```lua\\nlocal Array = SortedArray.new({1, 2, 3, 4})\\nlocal function Reducer(PreviousValue, CurrentValue)\\n\\treturn PreviousValue + CurrentValue\\nend\\n\\nprint(Array:Reduce(Reducer)) -- 10\\nprint(Array:Reduce(Reducer, 5)) -- 15\\n```","params":[{"name":"Predicate","desc":"The function you are running.","lua_type":"<T>(Accumulator: T, Value: T, Index: int, self: SortedArray<T>) -> T"},{"name":"InitialValue","desc":"The initial value of the accumulator. Defaults to the first value in the SortedArray.","lua_type":"T?"}],"returns":[{"desc":"The final value of the accumulator.","lua_type":"T"}],"function_type":"method","source":{"line":233,"path":"src/DataStructures/SortedArray/init.lua"}},{"name":"ReduceRight","desc":"The ReduceRight method applies a function against an accumulator and each value of the array (from right-to-left) to reduce it to a single value.\\n\\n```lua\\nlocal Array = SortedArray.new({2, 30, 45, 100})\\nlocal function Reducer(PreviousValue, CurrentValue)\\n\\treturn PreviousValue - CurrentValue\\nend\\n\\nprint(Array:ReduceRight(Reducer)) -- prints 23\\nprint(Array:ReduceRight(Reducer, 2)) -- prints -175\\n```","params":[{"name":"Predicate","desc":"The function you are running.","lua_type":"<T>(Accumulator: T, Value: T, Index: int, self: SortedArray<T>) -> T"},{"name":"InitialValue","desc":"The initial value of the accumulator. Defaults to the first value in the SortedArray.","lua_type":"T?"}],"returns":[{"desc":"The final value of the accumulator.","lua_type":"T"}],"function_type":"method","source":{"line":273,"path":"src/DataStructures/SortedArray/init.lua"}},{"name":"Filter","desc":"The Filter method creates a new array with all elements that pass the test implemented by the provided function.\\n\\n```lua\\nlocal EvenArray = SortedArray.new({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}):Filter(function(Value)\\n\\treturn Value % 2 == 0\\nend)\\n\\nprint(EvenArray) -- {2, 4, 6, 8, 10}\\n```","params":[{"name":"Predicate","desc":"The function you are running.","lua_type":"<T>(Value: T, Index: int, self: SortedArray<T>) -> boolean?"}],"returns":[{"desc":"The filtered array.","lua_type":"Array<T>"}],"function_type":"method","source":{"line":324,"path":"src/DataStructures/SortedArray/init.lua"}},{"name":"FilterToSortedArray","desc":"The FilterToSortedArray method creates a new SortedArray with all elements that pass the test implemented by the provided function.\\n\\n```lua\\nlocal EvenArray = SortedArray.new({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}):FilterToSortedArray(function(Value)\\n\\treturn Value % 2 == 0\\nend)\\n\\nprint(EvenArray) -- SortedArray<[2, 4, 6, 8, 10]>\\n```","params":[{"name":"Predicate","desc":"The function you are running.","lua_type":"<T>(Value: T, Index: int, self: SortedArray<T>) -> boolean?"}],"returns":[{"desc":"The filtered array.","lua_type":"SortedArray<T>"}],"function_type":"method","source":{"line":352,"path":"src/DataStructures/SortedArray/init.lua"}},{"name":"Slice","desc":"The `Slice()` method returns a shallow copy of a portion of an array into a new SortedArray object selected from `StartIndex` to `EndIndex`\\n(`EndIndex` not included) where `StartIndex` and `EndIndex` represent the index of items in that array. The original array will not be modified.\\n\\n```lua\\nlocal Array = SortedArray.new({\\"Ant\\", \\"Bison\\", \\"Camel\\", \\"Duck\\", \\"Elephant\\"})\\nprint(Array:Slice(2)) -- {Camel, Duck, Elephant}\\nprint(Array:Slice(2, 4)) -- {Camel, Duck}\\nprint(Array:Slice(1, 5)) -- {Bison, Camel, Duck, Elephant}\\nprint(Array:Slice(-2)) -- {Duck, Elephant}\\nprint(Array:Slice(2, -1)) -- {Camel, Duck}\\n```","params":[{"name":"StartIndex","desc":"The zero-based index at which to start extraction. A negative index can be used, indicating an offset from the end of the sequence. `Slice(-2)` extracts the last two elements in the sequence. If this is not provided, it\'ll default to `0`. If it is greater than the index range of the sequence, an empty array is returned.","lua_type":"int?"},{"name":"EndIndex","desc":"Zero-based index before which to end extraction. `Slice` extracts up to but not including `EndIndex`. For example, `Slice(1, 4)` extracts the second element through the fourth element (elements indexed 1, 2, and 3). A negative index can be used, indicating an offset from the end of the sequence. `Slice(2, -1)` extracts the third element through the second-to-last element in the sequence. If `EndIndex` is omitted, `Slice` extracts through the end of the sequence (`#self`). If `EndIndex` is greater than the length of the sequence, slice extracts through to the end of the sequence (`#self`).","lua_type":"int?"}],"returns":[{"desc":"The sliced array.","lua_type":"Array<T>"}],"function_type":"method","source":{"line":397,"path":"src/DataStructures/SortedArray/init.lua"}},{"name":"SliceToSortedArray","desc":"The `Slice()` method returns a shallow copy of a portion of an array into a new SortedArray object selected from `StartIndex` to `EndIndex`\\n(`EndIndex` not included) where `StartIndex` and `EndIndex` represent the index of items in that array. The original array will not be modified.\\n\\n```lua\\nlocal Array = SortedArray.new({\\"Ant\\", \\"Bison\\", \\"Camel\\", \\"Duck\\", \\"Elephant\\"})\\nprint(Array:SliceToSortedArray(2)) -- SortedArray<[Camel, Duck, Elephant]>\\nprint(Array:SliceToSortedArray(2, 4)) -- SortedArray<[Camel, Duck]>\\nprint(Array:SliceToSortedArray(1, 5)) -- SortedArray<[Bison, Camel, Duck, Elephant]>\\nprint(Array:SliceToSortedArray(-2)) -- SortedArray<[Duck, Elephant]>\\nprint(Array:SliceToSortedArray(2, -1)) -- SortedArray<[Camel, Duck]>\\n```","params":[{"name":"StartIndex","desc":"The zero-based index at which to start extraction. A negative index can be used, indicating an offset from the end of the sequence. `Slice(-2)` extracts the last two elements in the sequence. If this is not provided, it\'ll default to `0`. If it is greater than the index range of the sequence, an empty array is returned.","lua_type":"int?"},{"name":"EndIndex","desc":"Zero-based index before which to end extraction. `Slice` extracts up to but not including `EndIndex`. For example, `Slice(1, 4)` extracts the second element through the fourth element (elements indexed 1, 2, and 3). A negative index can be used, indicating an offset from the end of the sequence. `Slice(2, -1)` extracts the third element through the second-to-last element in the sequence. If `EndIndex` is omitted, `Slice` extracts through the end of the sequence (`#self`). If `EndIndex` is greater than the length of the sequence, slice extracts through to the end of the sequence (`#self`).","lua_type":"int?"}],"returns":[{"desc":"The sliced array.","lua_type":"SortedArray<T>"}],"function_type":"method","source":{"line":436,"path":"src/DataStructures/SortedArray/init.lua"}},{"name":"MapFilter","desc":"A combination function of `Filter` and `Map`. If the predicate function returns nil, the value will not be included in the new list. Any other result will add the result value to the new list.\\n\\n```lua\\nlocal Array = SortedArray.new({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}):MapFilter(function(Value)\\n\\treturn if Value % 2 == 0 then if Value % 3 == 0 then nil else Value else nil\\nend)\\n\\nprint(Array) -- {2, 4, 8, 10}\\n```","params":[{"name":"Predicate","desc":"The function to map and filter with.","lua_type":"<T>(Value: T, Index: int, self: SortedArray<T>) -> T?"}],"returns":[{"desc":"The mapped and filtered array.","lua_type":"Array<T>"}],"function_type":"method","source":{"line":472,"path":"src/DataStructures/SortedArray/init.lua"}},{"name":"MapFilterToSortedArray","desc":"A combination function of `Filter` and `Map`. If the predicate function returns nil, the value will not be included in the new list. Any other result will add the result value to the new list.\\n\\n```lua\\nlocal Array = SortedArray.new({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}):MapFilterToSortedArray(function(Value)\\n\\treturn if Value % 2 == 0 then if Value % 3 == 0 then nil else Value else nil\\nend)\\n\\nprint(Array) -- SortedArray<[2, 4, 8, 10]>\\n```","params":[{"name":"Predicate","desc":"The function to map and filter with.","lua_type":"<T>(Value: T, Index: int, self: SortedArray<T>) -> T?"}],"returns":[{"desc":"The mapped and filtered array.","lua_type":"SortedArray<T>"}],"function_type":"method","source":{"line":501,"path":"src/DataStructures/SortedArray/init.lua"}},{"name":"Insert","desc":"Inserts an element in the proper place which would preserve the array\'s orderedness. Returns the index the element was inserted.\\n\\n```lua\\nlocal Array = SortedArray.new({1, 3, 5})\\nprint(Array:Insert(2)) -- 2\\nprint(Array:Insert(6)) -- 5\\nprint(Array:Insert(4)) -- 4\\nprint(Array) -- SortedArray<[1, 2, 3, 4, 5, 6]>\\n```","params":[{"name":"Value","desc":"The value you are inserting.","lua_type":"T"}],"returns":[{"desc":"The index the value was inserted at.","lua_type":"int"}],"function_type":"method","source":{"line":522,"path":"src/DataStructures/SortedArray/init.lua"}},{"name":"Find","desc":"Finds an Element in a SortedArray and returns its position (or nil if non-existant).\\n\\n```lua\\nlocal Array = SortedArray.new({1, 2, 3, 4, 5})\\nprint(Array:Find(3)) -- 3\\nprint(Array:Find(6)) -- nil\\n```","params":[{"name":"Value","desc":"The element to find or something that will be matched by the `Eq` function.","lua_type":"T"},{"name":"Eq","desc":"An optional function which checks for equality between the passed-in element and the other elements in the SortedArray.","lua_type":"(<T>(Value: T, Other: T) -> boolean)?"},{"name":"Lt","desc":"An optional less-than comparison function, which falls back on the comparison passed in from `SortedArray.new`.","lua_type":"(<T>(Value: T, Other: T) -> boolean)?"},{"name":"Low","desc":"The lowest index to search. Defaults to 1.","lua_type":"int?"},{"name":"High","desc":"The high index to search. Defaults to the length of the SortedArray.","lua_type":"int?"}],"returns":[{"desc":"The numerical index of the element which was found, else nil.","lua_type":"int?"}],"function_type":"method","source":{"line":555,"path":"src/DataStructures/SortedArray/init.lua"}},{"name":"Copy","desc":"Makes a shallow copy of the SortedArray.\\n\\n```lua\\nprint(SortedArray.new({1, 2, 3, 4, 5}):Copy()) -- {1, 2, 3, 4, 5}\\n```","params":[],"returns":[{"desc":"The shallow copied array.","lua_type":"Array<T>"}],"function_type":"method","source":{"line":572,"path":"src/DataStructures/SortedArray/init.lua"}},{"name":"Clone","desc":"Makes a shallow copy of the SortedArray and returns a new SortedArray.\\n\\n```lua\\nprint(SortedArray.new({1, 2, 3, 4, 5}):Clone()) -- SortedArray<[1, 2, 3, 4, 5]>\\n```","params":[],"returns":[{"desc":"The shallow copied array.","lua_type":"SortedArray<T>"}],"function_type":"method","source":{"line":586,"path":"src/DataStructures/SortedArray/init.lua"}},{"name":"RemoveElement","desc":"Searches the array via `SortedArray:Find(Signature, Eq, Lt)`. If found, it removes the value and returns the value, otherwise returns nil. Only removes a single occurence.\\n\\n```lua\\nlocal Array = SortedArray.new({1, 2, 3, 4, 5})\\nprint(Array:RemoveElement(3)) -- 3\\nprint(Array:RemoveElement(6)) -- nil\\n```","params":[{"name":"Signature","desc":"The value you want to remove.","lua_type":"T"},{"name":"Eq","desc":"An optional function which checks for equality between the passed-in element and the other elements in the SortedArray.","lua_type":"(<T>(Value: T, Other: T) -> boolean)?"},{"name":"Lt","desc":"An optional less-than comparison function, which falls back on the comparison passed in from `SortedArray.new`.","lua_type":"(<T>(Value: T, Other: T) -> boolean)?"}],"returns":[{"desc":"The removed value.","lua_type":"T?"}],"function_type":"method","source":{"line":608,"path":"src/DataStructures/SortedArray/init.lua"}},{"name":"Sort","desc":"Does `table.sort(self, self.Comparison)` and returns the SortedArray.","params":[],"returns":[{"desc":"Returns self.","lua_type":"SortedArray<T>"}],"function_type":"method","source":{"line":617,"path":"src/DataStructures/SortedArray/init.lua"}},{"name":"SortIndex","desc":"Removes the value at Index and re-inserts it. This is useful for when a value may have updated in a way that could change it\'s position in a SortedArray. Returns Index.","params":[{"name":"Index","desc":"The index to resort.","lua_type":"int"}],"returns":[{"desc":"The new position.","lua_type":"int"}],"function_type":"method","source":{"line":627,"path":"src/DataStructures/SortedArray/init.lua"}},{"name":"SortElement","desc":"Calls `RemoveElement(Signature, Eq, Lt)` and re-inserts the value. This is useful for when a value may have updated in a way that could change its position in a SortedArray. Returns Index.","params":[{"name":"Signature","desc":"The value you want to re-sort.","lua_type":"T"},{"name":"Eq","desc":"An optional function which checks for equality between the passed-in element and the other elements in the SortedArray.","lua_type":"(<T>(Value: T, Other: T) -> boolean)?"},{"name":"Lt","desc":"An optional less-than comparison function, which falls back on the comparison passed in from `SortedArray.new`.","lua_type":"(<T>(Value: T, Other: T) -> boolean)?"}],"returns":[{"desc":"The new position.","lua_type":"int"}],"function_type":"method","source":{"line":642,"path":"src/DataStructures/SortedArray/init.lua"}},{"name":"Iterator","desc":":::warning Performance\\nIf you care about performance, do not use this function. Just do `for Index, Value in ipairs(SortedArray) do` directly.\\n:::\\n\\nThis returns an iterator for the SortedArray. This only exists for consistency reasons.","params":[],"returns":[{"desc":"The `ipairs` iterator.","lua_type":"IteratorFunction"}],"function_type":"method","source":{"line":657,"path":"src/DataStructures/SortedArray/init.lua"}},{"name":"Concat","desc":"Calls `table.concat` on the SortedArray.","params":[{"name":"Separator","desc":"The separator of the entries.","lua_type":"string?"},{"name":"StartIndex","desc":"The index to start concatenating from.","lua_type":"int?"},{"name":"EndIndex","desc":"The index to end concatenating at.","lua_type":"int?"}],"returns":[{"desc":"The stringify SortedArray.","lua_type":"string"}],"function_type":"method","source":{"line":669,"path":"src/DataStructures/SortedArray/init.lua"}},{"name":"RemoveIndex","desc":"Calls `table.remove` on the SortedArray.","params":[{"name":"Index","desc":"The index to remove.","lua_type":"int?"}],"returns":[{"desc":"The removed value.","lua_type":"T?"}],"function_type":"method","source":{"line":678,"path":"src/DataStructures/SortedArray/init.lua"}},{"name":"Unpack","desc":"Calls `table.unpack` on the SortedArray.","params":[{"name":"StartIndex","desc":"The index to start unpacking at.","lua_type":"int?"},{"name":"EndIndex","desc":"The index to end unpacking at.","lua_type":"int?"}],"returns":[{"desc":"The unpacked array.","lua_type":"...T"}],"function_type":"method","source":{"line":688,"path":"src/DataStructures/SortedArray/init.lua"}},{"name":"GetIntersection","desc":"Returns a SortedArray of Commonalities between self and another SortedArray. If applicable, the returned SortedArray will inherit the Comparison function from self.","params":[{"name":"SortedArray2","desc":"The SortedArray to get the intersection with.","lua_type":"SortedArray<T>"},{"name":"Eq","desc":"An optional function which checks for equality between the passed-in element and the other elements in the SortedArray.","lua_type":"(<T>(Value: T, Other: T) -> boolean)?"},{"name":"Lt","desc":"An optional less-than comparison function, which falls back on the comparison passed in from `SortedArray.new`.","lua_type":"(<T>(Value: T, Other: T) -> boolean)?"}],"returns":[{"desc":"A SortedArray with the common values between self and SortedArray2.","lua_type":"SortedArray<T>"}],"function_type":"method","errors":[{"lua_type":"\\"InvalidSortedArray\\"","desc":"Thrown when SortedArray2 is not a SortedArray."}],"source":{"line":701,"path":"src/DataStructures/SortedArray/init.lua"}}],"properties":[],"types":[],"name":"SortedArray","desc":"A class to create sorted arrays. Must contain objects comparable to\\none another (that can use the `<` and `==` operators). Numbers and\\nstrings support these operators by default.\\n\\n```lua\\nlocal SortedArray = require(\\"SortedArray\\")\\nlocal Array1 = SortedArray.new({1, 2, 3}) -- Gets sorted.\\nlocal Array2 = SortedArray.new()\\n```","source":{"line":17,"path":"src/DataStructures/SortedArray/init.lua"}}')}}]);